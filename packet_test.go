package mdns

import (
	"net"
	"reflect"
	"testing"
)

func TestPacket(t *testing.T) {
	for _, test := range []struct {
		name               string
		raw                []byte
		pkt                packet
		expectedMarshalErr error
	}{
		{
			name:               "Invalid Packet",
			raw:                []byte{},
			pkt:                packet{},
			expectedMarshalErr: errPacketHeaderTooSmall,
		},
		{
			name:               "Empty Query Response",
			raw:                []byte{0x00, 0x05, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			pkt:                packet{id: 0x005, flags: isQueryResponseMask | isAuthoritativeOrTruncatedMask},
			expectedMarshalErr: nil,
		},
		{
			name: "One Question",
			raw: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x5f, 0x63, 0x6f,
				0x6d, 0x70, 0x61, 0x6e, 0x69, 0x6f, 0x6e, 0x2d, 0x6c, 0x69, 0x6e, 0x6b, 0x04, 0x5f, 0x74, 0x63,
				0x70, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x80, 0x01,
			},
			pkt: packet{
				questions: []*Question{
					{"_companion-link._tcp.local", 0xc, 0x8001},
				},
			},
			expectedMarshalErr: nil,
		},
		{
			name: "One Answer",
			raw: []byte{0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x24, 0x34, 0x36, 0x39,
				0x36, 0x30, 0x61, 0x35, 0x37, 0x2d, 0x35, 0x34, 0x37, 0x33, 0x2d, 0x34, 0x63, 0x61, 0x38, 0x2d,
				0x39, 0x62, 0x35, 0x39, 0x2d, 0x66, 0x33, 0x36, 0x33, 0x64, 0x33, 0x61, 0x31, 0x64, 0x62, 0x30,
				0x34, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78,
				0x00, 0x04, 0xc0, 0xa8, 0x01, 0x0a,
			},
			pkt: packet{
				flags: isQueryResponseMask | isAuthoritativeOrTruncatedMask,
				answers: []*Answer{
					{"46960a57-5473-4ca8-9b59-f363d3a1db04.local", 1, 1, true, 120, net.ParseIP("192.168.1.10")},
				},
			},
			expectedMarshalErr: nil,
		},
	} {
		dst := packet{}
		err := dst.Unmarshal(test.raw)
		if err != test.expectedMarshalErr {
			t.Fatalf("Unexpected error (%v) expected (%v)", err, test.expectedMarshalErr)
		}
		if test.expectedMarshalErr != nil {
			continue // Only do equality checks in non-err case
		}

		dstRaw, _ := dst.Marshal()
		if !reflect.DeepEqual(dst, test.pkt) {
			t.Fatalf("%s Unmarshal: got %#v, want %#v", test.name, dst, test.pkt)
		} else if !reflect.DeepEqual(dstRaw, test.raw) {
			t.Fatalf("%s Marshal: got %#v, want %#v", test.name, dstRaw, test.raw)
		}
	}
}
